--- /Users/neb1/Downloads/gVirtualXRay-1.0.0-Source/include/gVirtualXRay/PolygonMesh.inl	2014-12-17 11:54:32.000000000 +0100
+++ gVirtualXRay-1.0.0-Source/include/gVirtualXRay/PolygonMesh.inl	2019-02-13 09:26:30.000000000 +0100
@@ -80,8 +80,8 @@
 inline PolygonMesh::~PolygonMesh()
 //--------------------------------
 {
-	// Make sure the VBO and the dynamically allocated memory are released
-	reset();
+    // Make sure the VBO and the dynamically allocated memory are released
+    reset();
 }
 
 
@@ -89,8 +89,8 @@
 inline void PolygonMesh::setFilename(const char* aFilename)
 //---------------------------------------------------------
 {
-	// Store the name of the file that contains the polygon mesh
-	m_filename = aFilename;
+    // Store the name of the file that contains the polygon mesh
+    m_filename = aFilename;
 }
 
 
@@ -98,8 +98,8 @@
 inline void PolygonMesh::setFilename(const std::string& aFilename)
 //----------------------------------------------------------------
 {
-	// Store the name of the file that contains the polygon mesh
-	m_filename = aFilename;
+    // Store the name of the file that contains the polygon mesh
+    m_filename = aFilename;
 }
 
 
@@ -107,8 +107,8 @@
 inline void PolygonMesh::setFileName(const char* aFilename)
 //---------------------------------------------------------
 {
-	// Store the name of the file that contains the polygon mesh
-	m_filename = aFilename;
+    // Store the name of the file that contains the polygon mesh
+    m_filename = aFilename;
 }
 
 
@@ -116,8 +116,8 @@
 inline void PolygonMesh::setFileName(const std::string& aFilename)
 //----------------------------------------------------------------
 {
-	// Store the name of the file that contains the polygon mesh
-	m_filename = aFilename;
+    // Store the name of the file that contains the polygon mesh
+    m_filename = aFilename;
 }
 
 
@@ -125,8 +125,8 @@
 inline const std::string& PolygonMesh::getFilename() const
 //--------------------------------------------------------
 {
-	// Return the name of the file that contains the polygon mesh
-	return (m_filename);
+    // Return the name of the file that contains the polygon mesh
+    return (m_filename);
 }
 
 
@@ -134,8 +134,8 @@
 inline const std::string& PolygonMesh::getFileName() const
 //--------------------------------------------------------
 {
-	// Return the name of the file that contains the polygon mesh
-	return (m_filename);
+    // Return the name of the file that contains the polygon mesh
+    return (m_filename);
 }
 
 
@@ -149,13 +149,13 @@
         m_vbo.reset(createVBO());
     }
 
-	// There is no data to store in a VBO
-	if (m_number_of_vertices && (getVertexNormalNumber() || getFaceNormalNumber()))
-	{
-		// Create a VBO if possible
-		updateVBO(aTypeOfVBO, aTypeOfPrimitive);
-	}
-	return (m_vbo->isReady());
+    // There is no data to store in a VBO
+    if (m_number_of_vertices && (getVertexNormalNumber() || getFaceNormalNumber()))
+    {
+        // Create a VBO if possible
+        updateVBO(aTypeOfVBO, aTypeOfPrimitive);
+    }
+    return (m_vbo->isReady());
 }
 
 
@@ -163,8 +163,8 @@
 inline bool PolygonMesh::getUseHounsfieldValueFlag() const
 //--------------------------------------------------------
 {
-	// Return true if the Hounsfield value is used, false if the attenuation coefficient is used
-	return (m_use_hounsfield_value);
+    // Return true if the Hounsfield value is used, false if the attenuation coefficient is used
+    return (m_use_hounsfield_value);
 }
 
 
@@ -172,11 +172,11 @@
 inline void PolygonMesh::setHounsfieldValue(const RATIONAL_NUMBER& aHounsfieldValue)
 //----------------------------------------------------------------------------------
 {
-	// Set the Hounsfield value
-	m_hounsfield_value = aHounsfieldValue;
+    // Set the Hounsfield value
+    m_hounsfield_value = aHounsfieldValue;
 
-	// The Hounsfield value will be used instead of the attenuation coefficient
-	m_use_hounsfield_value = true;
+    // The Hounsfield value will be used instead of the attenuation coefficient
+    m_use_hounsfield_value = true;
 }
 
 
@@ -184,11 +184,11 @@
 inline void PolygonMesh::setAttenuationCoefficient(const RATIONAL_NUMBER& anAttenuationCoefficient)
 //-------------------------------------------------------------------------------------------------
 {
-	// Set the attenuation coefficient
-	m_attenuation_coefficient = anAttenuationCoefficient;
+    // Set the attenuation coefficient
+    m_attenuation_coefficient = anAttenuationCoefficient;
 
-	// The attenuation coefficient will be used instead of the Hounsfield value
-	m_use_hounsfield_value = false;
+    // The attenuation coefficient will be used instead of the Hounsfield value
+    m_use_hounsfield_value = false;
 }
 
 
@@ -196,8 +196,8 @@
 inline RATIONAL_NUMBER PolygonMesh::getHounsfieldValue() const
 //------------------------------------------------------------
 {
-	// Return the Hounsfield value
-	return (m_hounsfield_value);
+    // Return the Hounsfield value
+    return (m_hounsfield_value);
 }
 
 
@@ -205,8 +205,8 @@
 inline RATIONAL_NUMBER PolygonMesh::getAttenuationCoefficient() const
 //-------------------------------------------------------------------
 {
-	// Return the attenuation coefficient
-	return (m_attenuation_coefficient);
+    // Return the attenuation coefficient
+    return (m_attenuation_coefficient);
 }
 
 
@@ -214,7 +214,7 @@
 inline const VEC3& PolygonMesh::getMinCorner() const
 //--------------------------------------------------
 {
-	// Return the bounding box lower corner
+    // Return the bounding box lower corner
     return (m_min_corner);
 }
 
@@ -223,8 +223,8 @@
 inline const VEC3& PolygonMesh::getMaxCorner() const
 //--------------------------------------------------
 {
-	// Return the bounding box upper corner
-	return (m_max_corner);
+    // Return the bounding box upper corner
+    return (m_max_corner);
 }
 
 
@@ -232,9 +232,9 @@
 inline unsigned int PolygonMesh::getFaceNormalNumber() const
 //----------------------------------------------------------
 {
-	// Return the number of normal vectors
-	// There are 3 GLfloat values per normal
-	return (m_p_face_normal_set.size() / 3);
+    // Return the number of normal vectors
+    // There are 3 GLfloat values per normal
+    return (m_p_face_normal_set.size() / 3);
 }
 
 
@@ -242,9 +242,9 @@
 inline unsigned int PolygonMesh::getVertexNormalNumber() const
 //------------------------------------------------------------
 {
-	// Return the number of normal vectors
-	// There are 3 GLfloat values per normal
-	return (m_p_vertex_normal_set.size() / 3);
+    // Return the number of normal vectors
+    // There are 3 GLfloat values per normal
+    return (m_p_vertex_normal_set.size() / 3);
 }
 
 
@@ -252,7 +252,7 @@
 inline unsigned int PolygonMesh::getVertexNumber() const
 //------------------------------------------------------
 {
-	return (m_number_of_vertices);
+    return (m_number_of_vertices);
 }
 
 
@@ -260,7 +260,7 @@
 inline unsigned int PolygonMesh::getIndexNumber() const
 //-----------------------------------------------------
 {
-	return (m_number_of_indices);
+    return (m_number_of_indices);
 }
 
 
@@ -268,14 +268,14 @@
 inline VEC3 PolygonMesh::getFaceNormal(unsigned int anIndex) const
 //----------------------------------------------------------------
 {
-	if (getFaceNormalNumber() <= anIndex)
-	{
-		throw OutOfBoundsException(__FILE__, __FUNCTION__, __LINE__);
-	}
-	
-	return (VEC3(m_p_face_normal_set[anIndex * 3 + 0],
-			m_p_face_normal_set[anIndex * 3 + 1],
-			m_p_face_normal_set[anIndex * 3 + 2]));
+    if (getFaceNormalNumber() <= anIndex)
+    {
+        throw OutOfBoundsException(__FILE__, __FUNCTION__, __LINE__);
+    }
+
+    return (VEC3(m_p_face_normal_set[anIndex * 3 + 0],
+            m_p_face_normal_set[anIndex * 3 + 1],
+            m_p_face_normal_set[anIndex * 3 + 2]));
 }
 
 
@@ -283,14 +283,14 @@
 inline VEC3 PolygonMesh::getVertexNormal(unsigned int anIndex) const
 //------------------------------------------------------------------
 {
-	if (getVertexNormalNumber() <= anIndex)
-	{
-		throw OutOfBoundsException(__FILE__, __FUNCTION__, __LINE__);
-	}
-	
-	return (VEC3(m_p_vertex_normal_set[anIndex * 3 + 0],
-			m_p_vertex_normal_set[anIndex * 3 + 1],
-			m_p_vertex_normal_set[anIndex * 3 + 2]));
+    if (getVertexNormalNumber() <= anIndex)
+    {
+        throw OutOfBoundsException(__FILE__, __FUNCTION__, __LINE__);
+    }
+
+    return (VEC3(m_p_vertex_normal_set[anIndex * 3 + 0],
+            m_p_vertex_normal_set[anIndex * 3 + 1],
+            m_p_vertex_normal_set[anIndex * 3 + 2]));
 }
 
 
@@ -298,27 +298,27 @@
 inline void PolygonMesh::computeBoundingBox()
 //-------------------------------------------
 {
-	// There are vertices
-	if (m_number_of_vertices)
-	{
-		m_min_corner = getVertex(0);
-		m_max_corner = getVertex(0);
-
-		for (unsigned int i(1); i < m_number_of_vertices; ++i)
-		{
-			VEC3 vertex(getVertex(i));
-
-			if (m_min_corner.getX() > vertex.getX()) m_min_corner.setX(vertex.getX());
-			if (m_max_corner.getX() < vertex.getX()) m_max_corner.setX(vertex.getX());
-			if (m_min_corner.getY() > vertex.getY()) m_min_corner.setY(vertex.getY());
-			if (m_max_corner.getY() < vertex.getY()) m_max_corner.setY(vertex.getY());
-			if (m_min_corner.getZ() > vertex.getZ()) m_min_corner.setZ(vertex.getZ());
-			if (m_max_corner.getZ() < vertex.getZ()) m_max_corner.setZ(vertex.getZ());
-		}
-
-		// Compute diagonal size
-		m_bounding_box_diagonal = (m_min_corner - m_max_corner).length();
-	}
+    // There are vertices
+    if (m_number_of_vertices)
+    {
+        m_min_corner = getVertex(0);
+        m_max_corner = getVertex(0);
+
+        for (unsigned int i(1); i < m_number_of_vertices; ++i)
+        {
+            VEC3 vertex(getVertex(i));
+
+            if (m_min_corner.getX() > vertex.getX()) m_min_corner.setX(vertex.getX());
+            if (m_max_corner.getX() < vertex.getX()) m_max_corner.setX(vertex.getX());
+            if (m_min_corner.getY() > vertex.getY()) m_min_corner.setY(vertex.getY());
+            if (m_max_corner.getY() < vertex.getY()) m_max_corner.setY(vertex.getY());
+            if (m_min_corner.getZ() > vertex.getZ()) m_min_corner.setZ(vertex.getZ());
+            if (m_max_corner.getZ() < vertex.getZ()) m_max_corner.setZ(vertex.getZ());
+        }
+
+        // Compute diagonal size
+        m_bounding_box_diagonal = (m_min_corner - m_max_corner).length();
+    }
 }
 
 
@@ -326,32 +326,32 @@
 inline void PolygonMesh::applyScale(const RATIONAL_NUMBER& aScale)
 //----------------------------------------------------------------
 {
-	// There are vertices
-	if (m_number_of_vertices)
-	{
-		for (unsigned int i(0); i < m_number_of_vertices; ++i)
-		{
-			VEC3 vertex(getVertex(i) * aScale);
-			setVertex(i, vertex);
-		}
-
-		// Update the bounding box
-		m_min_corner *= aScale;
-		m_max_corner *= aScale;
-		m_bounding_box_diagonal *= aScale;
-
-	    // Create the VBO if needed
-		if (!m_vbo.get())
-		{
-		    m_vbo.reset(createVBO());
-		}
+    // There are vertices
+    if (m_number_of_vertices)
+    {
+        for (unsigned int i(0); i < m_number_of_vertices; ++i)
+        {
+            VEC3 vertex(getVertex(i) * aScale);
+            setVertex(i, vertex);
+        }
+
+        // Update the bounding box
+        m_min_corner *= aScale;
+        m_max_corner *= aScale;
+        m_bounding_box_diagonal *= aScale;
+
+        // Create the VBO if needed
+        if (!m_vbo.get())
+        {
+            m_vbo.reset(createVBO());
+        }
 
         // Update the VBO
-		if (m_vbo->isReady())
-		{
-			updateVBO(m_vbo->getBufferUsageHint(), m_vbo->getPrimitiveType());
-		}
-	}
+        if (m_vbo->isReady())
+        {
+            updateVBO(m_vbo->getBufferUsageHint(), m_vbo->getPrimitiveType());
+        }
+    }
 }
 
 
@@ -359,40 +359,66 @@
 inline void PolygonMesh::translate(const VEC3& aTranslationVector)
 //----------------------------------------------------------------
 {
-	if (m_number_of_vertices)
-	{
-		for (unsigned int i(0); i < m_number_of_vertices; i++)
-		{
-			VEC3 vertex(getVertex(i) + aTranslationVector);
-			setVertex(i, vertex);
-		}
-	
-		m_min_corner += aTranslationVector;
-		m_max_corner += aTranslationVector;
-	
-		// Create the VBO if needed
-		if (!m_vbo.get())
-		{
-		    m_vbo.reset(createVBO());
-		}
-
-		// Update the VBO
-		if (m_vbo->isReady())
-		{
-			updateVBO(m_vbo->getBufferUsageHint(), m_vbo->getPrimitiveType());
-		}
-	}
+    if (m_number_of_vertices)
+    {
+        for (unsigned int i(0); i < m_number_of_vertices; i++)
+        {
+            VEC3 vertex(getVertex(i) + aTranslationVector);
+            setVertex(i, vertex);
+        }
+
+        m_min_corner += aTranslationVector;
+        m_max_corner += aTranslationVector;
+
+        // Create the VBO if needed
+        if (!m_vbo.get())
+        {
+            m_vbo.reset(createVBO());
+        }
+
+        // Update the VBO
+        if (m_vbo->isReady())
+        {
+            updateVBO(m_vbo->getBufferUsageHint(), m_vbo->getPrimitiveType());
+        }
+    }
 }
 
+//----------------------------------------------------------------
+inline void PolygonMesh::rotate( const MATRIX4 & rotationMatrix)
+//----------------------------------------------------------------
+{
+    if (m_number_of_vertices)
+    {
+        for (unsigned int i(0); i < m_number_of_vertices; i++)
+        {
+            VEC3 vertex( rotationMatrix*getVertex(i) );
+            setVertex(i, vertex);
+        }
+        m_min_corner  = rotationMatrix*m_min_corner;
+        m_max_corner =  rotationMatrix* m_max_corner;
+        // Create the VBO if needed
+        if (!m_vbo.get())
+        {
+            m_vbo.reset(createVBO());
+        }
+
+        // Update the VBO
+        if (m_vbo->isReady())
+        {
+            updateVBO(m_vbo->getBufferUsageHint(), m_vbo->getPrimitiveType());
+        }
+    }
+}
 
 //-------------------------------------
 inline void PolygonMesh::moveToCentre()
 //-------------------------------------
 {
-	VEC3 translation_vector(m_min_corner + (m_max_corner - m_min_corner) / 2.0);
-	translation_vector *= -1.0;
+    VEC3 translation_vector(m_min_corner + (m_max_corner - m_min_corner) / 2.0);
+    translation_vector *= -1.0;
 
-	translate(translation_vector);
+    translate(translation_vector);
 }
 
 
@@ -400,20 +426,20 @@
 inline void PolygonMesh::inverNormalVectors()
 //-------------------------------------------
 {
-	for (std::vector<RATIONAL_NUMBER>::iterator ite(m_p_vertex_normal_set.begin());
-			ite != m_p_vertex_normal_set.end();
-			++ite)
-	{
-		*ite = -(*ite);
-	}
+    for (std::vector<RATIONAL_NUMBER>::iterator ite(m_p_vertex_normal_set.begin());
+         ite != m_p_vertex_normal_set.end();
+         ++ite)
+    {
+        *ite = -(*ite);
+    }
 
 
-	for (std::vector<RATIONAL_NUMBER>::iterator ite(m_p_face_normal_set.begin());
-			ite != m_p_face_normal_set.end();
-			++ite)
-	{
-		*ite = -(*ite);
-	}
+    for (std::vector<RATIONAL_NUMBER>::iterator ite(m_p_face_normal_set.begin());
+         ite != m_p_face_normal_set.end();
+         ++ite)
+    {
+        *ite = -(*ite);
+    }
 }
 
 
